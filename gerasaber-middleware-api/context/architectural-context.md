# Project Overview

This project defines a **Spring Boot middleware web application** designed to
act as a communication bridge between a **user-facing browser client** and a
remote **n8n automation server** integrated with **ChatGPT**.

The core functionalities are:
- Expose an endpoint to receive **multipart/form-data** uploads containing
  one or more files (PDF, DOCX, TXT, etc.) and a JSON payload with
  **processing instructions**.
- Forward the received payload and files to an **external n8n workflow
  endpoint** via HTTP.
- Expose a **webhook endpoint** to receive **asynchronous responses** from the
  n8n server, including a **PDF file generated by ChatGPT**.
- Store received PDF files securely in the **local file system** and optionally
  register file metadata in a relational database.

---

# Tech Stack Constraints

## Backend
- **Java 21** (already installed)
- **Gradle 8.7** (compatible with Spring Boot 3.x and already installed)
- **Spring Boot 3.x**
  - Enable **Java Virtual Threads** (via `spring.threads.virtual.enabled=true`)
  - Use **Spring Web MVC**
- **Maven Central** as the primary repository
- **Docker** version 27.5.1
- **Docker Compose** version 2.29.2
- **SLF4J + Logback** for structured logging
- **application.yml** for environment-based configurations
- **Lombok** for boilerplate reduction
- **Spring Validation** for request payload validation
- **Spring WebClient** for remote HTTP calls to the n8n server
- **Java NIO Files API** for file storage management

---

# Architectural Rules

## Launch Guidelines
- Create a `docker-compose.yml` with 2 services:
  - **middleware-api** → runs the backend service
- The middleware-api container must mount a volume for persistent file storage:
  - `/app/files:/var/app/files`

## Backend Guidelines

### Package Naming
- All Java classes must reside under the base package:
  ```
  br.com.gerasaber
  ```

### Layered & Clean Architecture
- Respect **SOLID** principles and **Clean Architecture** structure.
- Avoid cyclical dependencies between packages.
- Follow **Domain-Driven Design (DDD)** concepts:
  - Entities, Value Objects, Aggregates, and Repositories must be well-defined.
  - No **anemic domain models**.
  - Business logic must reside inside **Service components**, not controllers.
  - Each use case must live in its own folder under `/usecase`.

Example folder structure:
```
br/com/gerasaber/usecase/file/upload/
    endpoint   -> REST controllers
    contract   -> DTO request/response objects
    mapping    -> converters between domain and transport
    service    -> core business logic
```

### Endpoint Requirements

#### Upload Endpoint
- URL: `POST /api/upload`
- Accept `multipart/form-data`
  - One or more file parts
  - A JSON field named `instructions`
- Responsibilities:
  - Validate incoming files and payload
  - Forward them via HTTP to a configured n8n URL
  - Use Bearer Token Authentication if required
  - Return an acknowledgment response or task identifier

#### Webhook Endpoint
- URL: `POST /api/webhook/n8n-response`
- Accept JSON or multipart payload from n8n
- Responsibilities:
  - Validate the payload signature or token (if provided)
  - Decode Base64 PDF or extract multipart file
  - Store file under `/var/app/files/{timestamp}/`
  - Optionally persist metadata (request ID, file path, timestamp) in DB
  - Respond with a 200 OK JSON acknowledgment

### Endpoint Naming Conventions
- `UploadFileEndpoint` → `br/com/gerasaber/usecase/file/upload/endpoint`
- `HandleWebhookEndpoint` → `br/com/gerasaber/usecase/webhook/endpoint`

### HTTP Response Format
All successful responses must follow the standard format:
```json
{
  "data": <response_object>
}
```
Error responses must return:
```json
{
  "errors": ["error message 1", "error message 2"]
}
```

### Service Layer
- Each service must implement a corresponding interface (prefixed with `I`):
  ```java
  public interface IFileStorageService { ... }
  ```
- Keep services stateless and transactional when performing DB operations.

### Configuration Management
- All environment-sensitive properties (tokens, URLs, paths) must be defined in
  `application.yml` or externalized through environment variables:
  ```yaml
  n8n:
    base-url: ${N8N_BASE_URL}
    webhook-path: /webhook/chatgpt-summarization
    auth-token: ${N8N_AUTH_TOKEN}
  storage:
    local-path: /var/app/files
  ```

### Error Handling
- Implement centralized exception handling via `@ControllerAdvice`.
- Map exceptions to HTTP codes (400, 404, 500).
- Use custom exception classes for clear domain semantics.

### Logging
- Use SLF4J (`LoggerFactory.getLogger`) in all service and endpoint classes.
- Log request metadata (ID, timestamp, file name) and response summaries.
- Do **not** log full file contents.

---

# Summary
This backend project enforces **Clean Architecture**, **DDD principles**, and
**strict naming and folder conventions**.  
It ensures modularity, maintainability, and consistent behavior for the
middleware service that connects user file uploads, the n8n automation flow,
and ChatGPT-generated file responses.
